# 2217. 로프[S4]  

### 🌐 문제 링크:

https://www.acmicpc.net/problem/2217

# 💻 문제 설명

주어진 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수 있다.

하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다.
k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.

각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.

# **💡 풀이 과정**

## ✍ 문제 접근

이 문제는 **여러 개의 로프를 사용하여 들어올릴 수 있는 물체의 최대 중량을 구하는 문제**이며, **그리디 알고리즘**을 적용할 수 있다.

### ❓ **왜 그리디 알고리즘을 사용할 수 있는가?**

- 각각의 로프는 독립적으로 동작하며, **서로에게 영향을 주지 않는다.**
- 즉, 특정 로프를 사용할지 말지는 다른 로프의 선택에 영향을 미치지 않으므로 **현재 시점에서 최선의 선택을 해도 전체 최적해와 일치**할 가능성이 높다.

### 🔑 **문제 해결 방법**

- **로프를 여러 개 사용할 경우, 각 로프에는 동일한 중량이 부하된다.**
    - 예를 들어, **k** 개의 로프를 사용하면, 물체의 무게 **w** 가 걸릴 때 각 로프에는 w/k 만큼의 힘이 분배된다.
    - 따라서, **가장 약한(최소 중량을 버틸 수 있는) 로프가 전체 로프가 들 수 있는 무게의 한계가 된다.**
- **핵심 아이디어:**
    - **가장 작은 중량을 버틸 수 있는 로프를 기준으로 최대 중량을 계산한다.**
    - 하지만 **모든 로프를 사용할 필요는 없으므로**, 특정 개수의 로프만 사용했을 때 더 큰 중량을 들 수 있는 경우가 있다.
    - 따라서, **작은 값부터 차례대로 로프의 개수를 곱해보면서 최댓값을 갱신**한다.

### ⭐**구체적인 접근 방식**

1. **로프들을 오름차순 정렬**한다. → (가장 약한 로프부터 계산)
2. **각 로프를 포함하여 사용할 때의 최대 중량을 계산**한다.
    - 반복문을 통해 **i** 번째 로프부터 마지막 로프까지 사용하면 **(로프의 개수 - i)** 개의 로프를 사용할 수 있다.
    - **최대 중량 =**  (현재 로프가 버틸 수 있는 무게 × 사용할 로프 개수)
3. **모든 경우를 비교하여 최댓값을 찾는다.**
- 반복문이 진행될수록 사용할 수 있는 로프 개수가 줄어든다.
- 매번 최대 중량을 갱신하면서 최댓값을 구한다.

# ✏️ **풀이 코드**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        int[] ropes = new int[N];

        for (int i = 0; i < N; i++) {
            ropes[i] = Integer.parseInt(br.readLine());
        }

        Arrays.sort(ropes);

        int maxWeight = 0;
        for (int i = 0; i < N; i++) {
            int currentWeight = ropes[i] * (N - i);
            maxWeight = Math.max(maxWeight, currentWeight);  
        }

        System.out.println(maxWeight);
    }
}
```
